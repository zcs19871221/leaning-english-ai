<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Word Groups Toggle & Sort</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    .group { margin-bottom: 24px; }
    .word-btn {
      display: inline-block;
      margin: 4px 6px;
      padding: 8px 18px;
      background: #eee;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      min-width: 60px;
      text-align: center;
      transition: background 0.2s;
    }
    .word-btn.revealed {
      background: #d1e7dd;
      color: #222;
      border-color: #bcd0c7;
    }
    .group-title {
      font-weight: bold;
      margin-bottom: 6px;
      color: #2a4d69;
    }
    .btn-bar {
      position: sticky;
      top: 0;
      background: #fff;
      z-index: 10;
      padding: 12px 0 16px 0;
      margin-bottom: 18px;
      border-bottom: 1px solid #eee;
    }
    .btn-bar button {
      margin-right: 12px;
      padding: 10px 22px;
      font-size: 16px;
      background: #4d90fe;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn-bar button:hover {
      background: #357ae8;
    }
  </style>
</head>
<body>
  <div class="btn-bar">
    <button id="export-btn">导出</button>
    <button id="import-btn">导入</button>
    <input type="file" id="import-file" style="display:none" accept=".json,.txt">
  </div>
  <div id="groups"></div>

  <script>
    const STORAGE_KEY = 'wordGroupsAppData_v1';
    const REVIEW_INTERVALS = [1, 2, 4, 7, 15]; // 单位：天，可调整

    const defaultWordGroups = [
      ["considerable", "considerate"],
      ["initiative", "initiate", "initial", "initial"],
      ["panoramic", "promenade", "lemonade"],
      ["prey", "predator", "predate", "pray", "priest"],
      ["inhabit", "habitat", "habitation", "inhabitant"],
      ["epidemic", "endemic"],
      ["eternal", "ethereal"],
      ["turf", "tuft"],
      ["aboard", "abroad", "board"],
      ["cottage", "cabbage", "carriage"],
      ["equine", "aquatic"],
      ["boast", "boost"],
      ["scrub", "succumb", "scurry"],
      ["spirit", "sprite"],
      ["indulging", "undulating"],
      ["flip", "flap"],
      ["captivate", "captive", "capture"],
      ["lag", "lug", "tug"],
      ["loyal", "royal"],
      ["rustic", "rust", "rustle", "russet", "lush", "lash"],
      ["participate", "precipitate", "anticipate"],
      ["unite", "unit"],
      ["potato", "tomato"],
      ["couch", "coach"],
      ["avenue", "venue", "convention"],
      ["vibrant", "vibrance", "vibe"],
      ["flank", "plank"],
      ["pedal", "paddle"],
      ["dust", "dusk", "dawn"],
      ["adorn", "adore"],
      ["bow", "bowl"],
      ["spire", "spine", "spindly", "spindly", "spin"],
      ["stew", "strew", "straw"],
      ["captain", "subtitle", "caption"],
      ["sector", "section"],
      ["torch", "torture"],
      ["wonder", "wander"],
      ["concentric", "concentrate"],
      ["stump", "stamp"],
      ["recline", "decline", "incline"],
      ["rumble", "scramble", "ramble"],
      ["hammock", "hummock"],
      ["forage", "forge", "foliage"],
      ["swamp", "swath"],
      ["clamp", "clump"],
      ["crucial", "cruel"],
      ["hospitable", "hostile"],
      ["tempt", "attempt"],
      ["lavender", "vanilla"],
      ["assume", "unassuming"],
      ["reed", "reef"],
      ["specialist", "specialize", "special", "specialty"],
      ["handful", "handy"],
      ["incentive", "sensitive", "sensitize"],
      ["rough", "rugged", "jagged"],
      ["leash", "lease"],
      ["beckon", "reckon"],
      ["spin", "spindly"],
      ["morale", "moral", "mortal", "Immortal"],
      ["doorway", "doorstep"],
      ["evocative", "exacerbation", "evacuation", "excavation"],
      ["terrain", "terraced"],
      ["groves", "gloves"],
      ["geologic", "geometric", "geographic", "geothermal", "geology"],
      ["intend", "tend"],
      ["turn around", "round"],
      ["fudge", "fungus"],
      ["perspective", "perception", "prospect"],
      ["circumstance", "perimeter", "circumference"],
      ["proximity", "approximate"],
      ["breathe", "breath"],
      ["wiggle", "wobble"],
      ["leisure", "luxury"],
      ["flip", "flap"],
      ["juvenile", "rejuvenate"],
      ["ripple", "rip", "ripping"],
      ["stalk", "stake", "steak"],
      ["squelch", "squeal", "squeeze"],
      ["alien", "ally"],
      ["appropriate adj", "appropriate v"],
      ["billow", "blow"],
      ["serenity", "serene"],
      ["hushed", "hustled"],
      ["deck", "desk", "dock"],
      ["cedar", "cider"],
      ["strap", "strip", "stride", "string"],
      ["tilt", "lilt"],
      ["pinnacle", "barnacle"],
      ["spine", "spire"],
      ["crest", "crescent"],
      ["chill", "chilly"],
      ["cranial", "crane"],
      ["scorch", "scour"],
      ["shuffle", "commute", "shuttle"],
      ["joint", "jolt"],
      ["bend", "blend"],
      ["founder", "funder", "fund", "found", "find"],
      ["reverse", "revert"],
      ["compete", "complete"],
      ["brake", "bake"],
      ["creative", "intellectual", "innovative", "ingenuity"],
      ["capital", "capita"],
      ["nocturnal", "necropolis"],
      ["pitch", "ditch"],
      ["lick", "flick"],
      ["mood", "moor"],
      ["glacier", "glacial"],
      ["yurt", "yacht"],
      ["par for the course"],
      ["toward(s) the south", "due south"],
      ["gaze", "glaze"],
      ["interference", "intervening", "intervene"],
      ["raven", "ravine"],
      ["roar", "roam"],
      ["affront", "confront", "comfort"],
      ["sign", "sigh"],
      ["tense", "intense"],
      ["visualize", "vision"],
      ["comprehensive", "comprehension"],
      ["prior", "priority"],
      ["isolated", "insulated"],
      ["bath", "bathe"],
      ["born to", "born from", "dairy farm"],
      ["radical", "radiate"],
      ["plate", "platter", "tray"],
      ["picky", "prick"],
      ["complain", "comply", "comprise"],
      ["runway", "runaway"],
      ["tuxedo", "detox", "toxic"],
      ["toll", "tow", "toe"],
      ["tycoon", "magnate", "mogul", "magnet"],
      ["tick", "ticket"],
      ["mock v", "mock adj"],
      ["squad", "squid"],
      ["synonym", "synonymous"],
      ["thrive", "strive"],
      ["ceremony", "cemetery"],
      ["spot - plot"],
      ["rustic"],
      ["assuming", "unassuming"],
      ["grin", "grind"],
      ["illuminate", "illusion"],
      ["haunt", "haul", "hound"],
      ["diesel", "kerosene", "petrol"],
      ["entwined", "intertwined"],
      ["across the street from 。。。"],
      ["sold out weeks in advance", "sold out in weeks"],
      ["sold out weeks in advance = 提前几周售罄（强调提前量）", "sold out in weeks = 几周内售罄（强调用时）"],
      ["spectrum", "spectre"],
      ["repute", "dispute", "deputy"],
      ["sturdy", "steady"],
      ["descent"],
      ["stake"],
      ["helm", "helmet"],
      ["lurk", "lurch"],
      ["crater", "crate", "cater"],
      ["burn", "burnt", "burnt"],
      ["iron", "steel", "copper", "aluminium"]
    ];

    function loadState() {
      try {
        const data = JSON.parse(localStorage.getItem(STORAGE_KEY));
        if (
          data &&
          Array.isArray(data.wordGroups) &&
          Array.isArray(data.revealed) &&
          Array.isArray(data.completedGroups)
        ) {
          return data;
        }
      } catch {}
      return {
        wordGroups: JSON.parse(JSON.stringify(defaultWordGroups)),
        revealed: defaultWordGroups.map(group => group.map(() => false)),
        completedGroups: []
      };
    }

    function saveState() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        wordGroups,
        revealed,
        completedGroups
      }));
    }

    // 检查defaultWordGroups是否有新单词，自动加入记忆队列
    function syncNewWords() {
      let changed = false;
      // 检查未完成组
      defaultWordGroups.forEach((group, gi) => {
        let idx = wordGroups.findIndex(g => JSON.stringify(g) === JSON.stringify(group));
        if (idx === -1) {
          // 新组，直接加入未完成
          wordGroups.push(group.slice());
          revealed.push(group.map(() => false));
          changed = true;
        } else {
          // 检查组内新单词
          group.forEach((word, wi) => {
            if (!wordGroups[idx].includes(word)) {
              wordGroups[idx].push(word);
              revealed[idx].push(false);
              changed = true;
            }
          });
        }
      });
      // 检查已完成组（不做自动合并，避免干扰复习进度）
      if (changed) saveState();
    }

    let { wordGroups, revealed, completedGroups } = loadState();
    syncNewWords();

    // pending selection info to pick text after render
    let pendingSelection = null;

    function performPendingSelection() {
      if (!pendingSelection) return;
      // run slightly async to ensure DOM is ready
      setTimeout(() => {
        const sel = window.getSelection();
        sel.removeAllRanges();
        const selector = `[data-group-type="${pendingSelection.type}"][data-gi="${pendingSelection.gi}"][data-wi="${pendingSelection.wi}"]`;
        const el = document.querySelector(selector);
        if (el && el.firstChild && el.firstChild.nodeType === Node.TEXT_NODE) {
          const range = document.createRange();
          range.selectNodeContents(el.firstChild);
          sel.removeAllRanges();
          sel.addRange(range);
        }
        pendingSelection = null;
      }, 0);
    }

    // 判断是否需要复习
    function getDueReviewGroups() {
      const now = Date.now();
      return completedGroups.filter(g => g.nextReview && g.nextReview <= now);
    }

    // 导出功能
    document.getElementById('export-btn').onclick = function() {
      const data = {
        wordGroups,
        revealed,
        completedGroups
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'word_state_' + new Date().toISOString().slice(0,10) + '.json';
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    };

    // 导入功能
    document.getElementById('import-btn').onclick = function() {
      document.getElementById('import-file').click();
    };
    document.getElementById('import-file').onchange = function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          const data = JSON.parse(evt.target.result);
          if (
            data &&
            Array.isArray(data.wordGroups) &&
            Array.isArray(data.revealed) &&
            Array.isArray(data.completedGroups)
          ) {
            wordGroups = data.wordGroups;
            revealed = data.revealed;
            completedGroups = data.completedGroups;
            // 导入后同步新单词
            syncNewWords();
            saveState();
            renderGroups();
            alert('导入成功！');
          } else {
            alert('文件格式不正确');
          }
        } catch {
          alert('文件解析失败');
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    };

    function renderGroups() {
      const groupsDiv = document.getElementById('groups');
      groupsDiv.innerHTML = '';

      // 先显示需要复习的组（来自completedGroups）
      const dueGroups = getDueReviewGroups();
      dueGroups.forEach((item, idx) => {
        const groupDiv = document.createElement('div');
        groupDiv.className = 'group';

        // find actual index in completedGroups so we can mark dataset correctly
        const compIndex = completedGroups.indexOf(item);

        item.group.forEach((word, wi) => {
          const btn = document.createElement('span');
          btn.className = 'word-btn' + (item.revealed[wi] ? ' revealed' : '');
          btn.textContent = item.revealed[wi] ? word : '●●●';
          // mark dataset for reliable lookup after re-render
          btn.dataset.groupType = 'due';
          btn.dataset.gi = compIndex;
          btn.dataset.wi = wi;

          // 只在单词展示时显示按钮
          if (item.revealed[wi]) {
            // 完成按钮
            const doneBtn = document.createElement('button');
            doneBtn.textContent = '完成';
            doneBtn.style.marginLeft = '8px';
            doneBtn.onclick = () => {
              // 该单词进入复习下一阶段
              item.reviewCount = (item.reviewCount || 0) + 1;
              if (item.reviewCount < REVIEW_INTERVALS.length) {
                item.nextReview = Date.now() + REVIEW_INTERVALS[item.reviewCount] * 24 * 60 * 60 * 1000;
              } else {
                // 彻底移除该单词
                item.group.splice(wi, 1);
                item.revealed.splice(wi, 1);
                // 如果组已空，移除整个组
                if (item.group.length === 0) {
                  completedGroups = completedGroups.filter(g => g !== item);
                }
              }
              saveState();
              renderGroups();
            };
            btn.appendChild(doneBtn);

            // 忘记了按钮
            const forgotBtn = document.createElement('button');
            forgotBtn.textContent = '忘记了';
            forgotBtn.style.marginLeft = '4px';
            forgotBtn.onclick = () => {
              // 该单词复习重置
              item.reviewCount = 0;
              item.nextReview = Date.now() + REVIEW_INTERVALS[0] * 24 * 60 * 60 * 1000;
              item.revealed[wi] = false;
              saveState();
              renderGroups();
            };
            btn.appendChild(forgotBtn);
          }

          btn.onclick = () => {
            const was = !!item.revealed[wi];
            item.revealed[wi] = !was;
            saveState();
            // if just revealed, schedule selection after render
            if (!was && item.revealed[wi]) {
              pendingSelection = { type: 'due', gi: compIndex, wi: wi };
            }
            renderGroups();
          };
          btn.ondblclick = (e) => {
            btn._skipNextClick = true;
          };
          groupDiv.appendChild(btn);
        });
        groupsDiv.appendChild(groupDiv);
      });

      // 再显示未完成的组
      wordGroups.forEach((group, gi) => {
        const groupDiv = document.createElement('div');
        groupDiv.className = 'group';

        group.forEach((word, wi) => {
          const btn = document.createElement('span');
          btn.className = 'word-btn' + (revealed[gi][wi] ? ' revealed' : '');
          btn.textContent = revealed[gi][wi] ? word : '●●●';
          btn.dataset.groupType = 'main';
          btn.dataset.gi = gi;
          btn.dataset.wi = wi;

          // 只在单词展示时显示按钮
          if (revealed[gi][wi]) {
            // 完成按钮
            const doneBtn = document.createElement('button');
            doneBtn.textContent = '完成';
            doneBtn.style.marginLeft = '8px';
            doneBtn.onclick = () => {
              // 单词移入复习队列（单词级别）
              // 先查找该组是否已在completedGroups
              let found = completedGroups.find(g => g.group === group);
              if (!found) {
                // 新建组
                found = {
                  group: [],
                  revealed: [],
                  index: gi,
                  completedAt: Date.now(),
                  reviewCount: 0,
                  nextReview: Date.now() + REVIEW_INTERVALS[0] * 24 * 60 * 60 * 1000
                };
                completedGroups.push(found);
              }
              found.group.push(word);
              found.revealed.push(false);

              // 从当前组移除该单词
              group.splice(wi, 1);
              revealed[gi].splice(wi, 1);
              // 如果组已空，移除整个组
              if (group.length === 0) {
                wordGroups.splice(gi, 1);
                revealed.splice(gi, 1);
              }
              saveState();
              renderGroups();
            };
            btn.appendChild(doneBtn);

            // 忘记了按钮
            const forgotBtn = document.createElement('button');
            forgotBtn.textContent = '忘记了';
            forgotBtn.style.marginLeft = '4px';
            forgotBtn.onclick = () => {
              revealed[gi][wi] = false;
              saveState();
              renderGroups();
            };
            btn.appendChild(forgotBtn);
          }

          btn.onclick = (e) => {
            if (btn._skipNextClick) {
              btn._skipNextClick = false;
              return;
            }
            const was = !!revealed[gi][wi];
            revealed[gi][wi] = !was;
            saveState();
            // if just revealed, set pending selection
            if (!was && revealed[gi][wi]) {
              pendingSelection = { type: 'main', gi: gi, wi: wi };
            }
            renderGroups();
          };
          btn.ondblclick = (e) => {
            revealed[gi][wi] = false;
            saveState();
            renderGroups();
            btn._skipNextClick = true;
          };

          groupDiv.appendChild(btn);
        });
        groupsDiv.appendChild(groupDiv);
      });

      // after DOM built, handle any pending selection
      performPendingSelection();
    }

    renderGroups();
  </script>
</body>
</html>
